<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>KICKR BIKE SHIFT — All Buttons (hard-coded, index-aware)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, Segoe UI, Roboto, sans-serif; padding: 1rem; }
    button { padding: .6rem 1rem; font-size: 1rem; margin-right: .5rem; }
    #status { margin-top: .6rem; }
    #log { margin-top: 1rem; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; border: 1px solid #ddd; padding: .75rem; border-radius: 6px; max-height: 50vh; overflow: auto; background: #fafafa; }
    .pill { display: inline-block; padding: .1rem .45rem; border-radius: 999px; font-size: .8rem; margin-left: .4rem; }
    .press { background: #e6f4ea; color: #137333; border: 1px solid #c4e3ce; }
    .release { background: #fce8e6; color: #a50e0e; border: 1px solid #f5c6c2; }
    .hex { color: #555; }
    .small { color: #555; }
  </style>
</head>
<body>
  <h1>KICKR BIKE SHIFT — All Buttons</h1>
  <p class="small">
    Uses Web Bluetooth to connect to your bike, subscribe to the Wahoo button characteristic, and detect the
    10 buttons you listed. (Requires HTTPS/localhost + a user click to start.)
  </p>

  <p>
    <button id="connect">Connect (name starts with “KICKR BIKE SHIFT”)</button>
    <button id="disconnect" disabled>Disconnect</button>
  </p>
  <div id="status">Status: <strong>Idle</strong></div>
  <div id="device"></div>
  <div id="log" aria-live="polite"></div>

  <script>
    // --- Wahoo GATT from your XML trace / SwiftControl web demo ---
    const WAHOO_SERVICE_UUID = 'a026ee0d-0a7d-4ab3-97fa-f1500f9feb8b';
    const WAHOO_CHAR_UUID    = 'a026e03c-0a7d-4ab3-97fa-f1500f9feb8b';

    // --- Hard-coded mapping (from your table) ----------------------------------------
    // Each short notification is 3 bytes, printed as 6 hex chars: PPQQRR
    // - PPQQ is a stable "family" for the button (first two bytes).
    // - RR is a rolling index where MSB=1 -> press, MSB=0 -> release; lower 7 bits increase each event.
    //
    // Your table shows the following families per button:
    //  Right Up:       0001RR (e.g., 0001E6, 000166, ...)
    //  Right Down:     8000RR
    //  Right Steer:    0008RR
    //  Left Up:        0200RR
    //  Left Down:      0400RR
    //  Left Steer:     2000RR
    //  Right Shift Up: 0004RR
    //  Right Shift Down: 0002RR
    //  Left Shift Up:  1000RR
    //  Left Shift Down:0800RR
    //
    // We key by the 4-hex prefix (PPQQ) to name the button, then decide press/release from RR.
    const PREFIX_TO_BUTTON = {
      '0001': 'Right Up',
      '8000': 'Right Down',
      '0008': 'Right Steer',
      '0200': 'Left Up',
      '0400': 'Left Down',
      '2000': 'Left Steer',
      '0004': 'Right Shift Up',
      '0002': 'Right Shift Down',
      '1000': 'Left Shift Up',
      '0800': 'Left Shift Down'
    };

    // --- Session state ----------------------------------------------------------------
    let device, server, characteristic;
    // Deduplication: remember last sequence handled for each (prefix,type)
    const lastSeqByPrefix = new Map(); // key: `${prefix}:${type}` -> seq

    // --- Utilities --------------------------------------------------------------------
    const $ = sel => document.querySelector(sel);
    const time = () => new Date().toLocaleTimeString();
    function log(msg='') {
      $('#log').insertAdjacentHTML('beforeend', `[${time()}] ${msg}\n`);
      const el = $('#log'); el.scrollTop = el.scrollHeight;
    }
    function setStatus(txt) { $('#status').innerHTML = `Status: <strong>${txt}</strong>`; }
    function setDevice(txt) { $('#device').textContent = txt || ''; }

    function toHex(dv) {
      const bytes = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
    }

    // Parse short frames like "PPQQRR" (e.g., "0001E6", "80005E", "0008B7", "000413")
    function parseShortFrame(hex) {
      if (!/^[0-9A-F]{6}$/i.test(hex)) return null;
      const prefix = hex.slice(0, 4); // PPQQ
      const rrHex  = hex.slice(4, 6); // RR
      if (!(prefix in PREFIX_TO_BUTTON)) return null;
      const idx = parseInt(rrHex, 16);
      const type = (idx & 0x80) ? 'press' : 'release'; // MSB of RR
      const seq  = idx & 0x7F;                         // rolling counter for dedupe
      return { prefix, rrHex, idx, type, seq, name: PREFIX_TO_BUTTON[prefix] };
    }

    // Some packets are long FF0F... dumps; we'll log them for reference but not use them here.
    function isLongFrame(hex) { return /^FF0F01/i.test(hex); }

    function shouldHandleOnce(prefix, type, seq) {
      const key = `${prefix}:${type}`;
      const last = lastSeqByPrefix.get(key);
      if (last === seq) return false;
      lastSeqByPrefix.set(key, seq);
      return true;
    }

    // --- Bluetooth glue ---------------------------------------------------------------
    async function connect() {
      try {
        setStatus('Requesting device…');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ namePrefix: 'KICKR BIKE SHIFT' }], // wildcard: "KICKR BIKE SHIFT *"
          optionalServices: [WAHOO_SERVICE_UUID]
        });
        device.addEventListener('gattserverdisconnected', onDisconnected);

        setStatus('Connecting…');
        server = await device.gatt.connect();

        const svc = await server.getPrimaryService(WAHOO_SERVICE_UUID);
        characteristic = await svc.getCharacteristic(WAHOO_CHAR_UUID);

        await characteristic.startNotifications();
        characteristic.addEventListener('characteristicvaluechanged', onNotification);

        setStatus('Connected & listening');
        $('#disconnect').disabled = false;
        $('#connect').disabled = true;
        setDevice(`Device: ${device.name} (${device.id})`);
        log('Notifications started on characteristic ' + WAHOO_CHAR_UUID);
      } catch (err) {
        setStatus('Error');
        log('ERROR: ' + err);
        console.error(err);
      }
    }

    async function disconnect() {
      try {
        $('#disconnect').disabled = true;
        if (characteristic) {
          try { await characteristic.stopNotifications(); } catch {}
          characteristic.removeEventListener('characteristicvaluechanged', onNotification);
        }
        if (device?.gatt?.connected) device.gatt.disconnect();
      } finally {
        setStatus('Disconnected');
        setDevice('');
        $('#connect').disabled = false;
        log('Disconnected.');
      }
    }

    function onDisconnected() {
      setStatus('Disconnected');
      $('#connect').disabled = false;
      $('#disconnect').disabled = true;
      setDevice('');
      log('GATT server disconnected.');
    }

    function onNotification(evt) {
      const hex = toHex(evt.target.value);

      // Prefer short-frame decoding (hard-coded families)
      const s = parseShortFrame(hex);
      if (s) {
        if (shouldHandleOnce(s.prefix, s.type, s.seq)) {
          log(`${s.name} ${s.type} <span class="pill ${s.type}">${s.type}</span> seq=${s.seq} ` +
              `<span class="hex">(${s.prefix}${s.rrHex})</span>`);
          // TODO: trigger actions here, for example:
          // if (s.name === 'Right Shift Up' && s.type === 'press') sendKey('K'); // example
        }
        return;
      }

      // Just log long frames for debugging (not needed for detection here)
      if (isLongFrame(hex)) {
        log(`Long frame <span class="hex">${hex}</span>`);
        return;
      }

      // Unknown frame (rare); keep it visible for reverse engineering
      log(`Notification <span class="hex">${hex}</span>`);
    }

    // UI wiring
    $('#connect').addEventListener('click', connect);
    $('#disconnect').addEventListener('click', disconnect);
  </script>
</body>
